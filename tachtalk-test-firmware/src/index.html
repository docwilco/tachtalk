<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>TachTalk Test Firmware</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script>const SSE_PORT = {{SSE_PORT}};</script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        h1 {
            color: #00ff00;
        }
        h2 {
            color: #88ff88;
            margin-top: 30px;
        }
        .section {
            background-color: #2a2a2a;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            border-left: 4px solid #00ff00;
        }
        .test-controls {
            background-color: #2a3a2a;
            border-left-color: #00ff00;
        }
        .wifi-section {
            background-color: #2a2a3a;
            border-left-color: #0088ff;
        }
        .metrics-section {
            background-color: #3a2a2a;
            border-left-color: #ff8800;
        }
        .form-group {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 150px;
            font-weight: bold;
        }
        input[type="text"], input[type="password"], input[type="number"], select {
            padding: 8px;
            border: 1px solid #444;
            background-color: #333;
            color: #fff;
            border-radius: 3px;
            width: 200px;
        }
        select {
            width: 218px;
        }
        button {
            background-color: #00ff00;
            color: #000;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }
        button:hover {
            background-color: #00dd00;
        }
        button:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
        }
        button.danger {
            background-color: #ff4444;
            color: #fff;
        }
        button.danger:hover {
            background-color: #dd2222;
        }
        .metric {
            display: inline-block;
            margin: 10px 20px 10px 0;
            padding: 10px 15px;
            background-color: #333;
            border-radius: 5px;
            min-width: 120px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #00ff00;
        }
        .metric-label {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-connected {
            background-color: #00ff00;
        }
        .status-disconnected {
            background-color: #ff4444;
        }
        .status-running {
            background-color: #ffaa00;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        #status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            display: none;
        }
        .success {
            background-color: #2d5016;
            border: 1px solid #00ff00;
        }
        .error {
            background-color: #5a1a1a;
            border: 1px solid #ff0000;
        }
        .pid-list {
            margin: 5px 0;
        }
        .pid-list input {
            width: 100%;
            font-family: monospace;
        }
        .help-text {
            font-size: 12px;
            color: #888;
            margin-top: 3px;
        }
        .mode-description {
            margin: 10px 0;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
            font-size: 14px;
        }
        .capture-section {
            display: none;
        }
        .capture-section.visible {
            display: block;
        }
        .pid-values-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-family: monospace;
        }
        .pid-values-table th {
            text-align: left;
            padding: 6px 10px;
            border-bottom: 1px solid #555;
            color: #888;
            font-size: 12px;
        }
        .pid-values-table td {
            padding: 6px 10px;
            border-bottom: 1px solid #333;
        }
        .pid-values-table .pid-hex {
            color: #00ff00;
            font-weight: bold;
        }
        .pid-values-table .pid-name {
            color: #ccc;
        }
        .pid-values-table .pid-decoded {
            color: #ffaa00;
            font-weight: bold;
        }
        .pid-values-table .pid-raw {
            color: #888;
            font-size: 12px;
        }
        .pid-values-table .pid-error {
            color: #ff4444;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #333;
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #00ff00;
            transition: width 0.3s;
        }
        .progress-fill.warning {
            background-color: #ffaa00;
        }
        .progress-fill.danger {
            background-color: #ff4444;
        }
        /* Capture Decoder */
        #decodeSection {
            border-left-color: #aa44ff;
            background-color: #2a2a3a;
        }
        .decode-header-card {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 4px 16px;
            padding: 12px;
            background-color: #333;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 15px;
        }
        .decode-header-card dt {
            color: #888;
            font-size: 12px;
            line-height: 22px;
        }
        .decode-header-card dd {
            margin: 0;
            font-family: monospace;
            line-height: 22px;
        }
        .decode-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .decode-controls label {
            width: auto;
            font-weight: normal;
            font-size: 14px;
        }
        .decode-controls select {
            width: auto;
        }
        .decode-record-count {
            color: #888;
            font-size: 13px;
            margin-left: auto;
        }
        .flag-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }
        .flag-overflow {
            background-color: #5a1a1a;
            color: #ff4444;
            border: 1px solid #ff4444;
        }
        .flag-ntp {
            background-color: #1a3a1a;
            color: #44ff44;
            border: 1px solid #44ff44;
        }
        .decode-col-header {
            display: flex;
            font-weight: bold;
            font-size: 13px;
            color: #888;
            border-bottom: 2px solid #555;
            padding: 6px 0;
            font-family: monospace;
            background-color: #2a2a2a;
            border-radius: 5px 5px 0 0;
        }
        .decode-scroll-container {
            height: 60vh;
            overflow-y: auto;
            position: relative;
            background-color: #222;
            border-radius: 0 0 5px 5px;
        }
        .decode-row {
            display: flex;
            position: absolute;
            left: 0;
            right: 0;
            height: 28px;
            line-height: 28px;
            font-family: monospace;
            font-size: 13px;
            border-bottom: 1px solid #2a2a2a;
        }
        .decode-row:hover {
            background-color: #3a3a4a;
        }
        .decode-row.rt-tx { background-color: rgba(0, 100, 255, 0.08); }
        .decode-row.rt-rx { background-color: rgba(0, 200, 0, 0.08); }
        .decode-row.rt-connect { background-color: rgba(255, 170, 0, 0.08); }
        .decode-row.rt-disconnect { background-color: rgba(255, 68, 68, 0.08); }
        .dc-num { width: 60px; text-align: right; padding-right: 8px; flex-shrink: 0; color: #666; }
        .dc-time { width: 90px; text-align: right; padding-right: 8px; flex-shrink: 0; }
        .dc-type { width: 100px; text-align: center; flex-shrink: 0; }
        .dc-bytes { width: 55px; text-align: right; padding-right: 8px; flex-shrink: 0; color: #888; }
        .dc-data { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding-left: 8px; }
        .type-badge {
            display: inline-block;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
        }
        .type-badge.rt-tx { background-color: #1a3a6a; color: #4488ff; }
        .type-badge.rt-rx { background-color: #1a4a1a; color: #44cc44; }
        .type-badge.rt-connect { background-color: #4a3a1a; color: #ffaa00; }
        .type-badge.rt-disconnect { background-color: #4a1a1a; color: #ff4444; }
    </style>
</head>
<body>
    <div class="container">
        <h1>TachTalk Test Firmware</h1>
        <div id="status"></div>

        <!-- Test Controls -->
        <div class="section test-controls">
            <h2 style="margin-top: 0;">Test Controls</h2>
            
            <div class="form-group">
                <label>Query Mode:</label>
                <select id="queryMode">
                    <option value="no_count">1. NoCount (baseline)</option>
                    <option value="always_one">2. AlwaysOne (append " 1")</option>
                    <option value="adaptive_count">3. AdaptiveCount (detect count)</option>
                    <option value="raw_capture">4. RawCapture (TCP proxy)</option>
                </select>
            </div>
            
            <div id="modeDescription" class="mode-description"></div>
            
            <div id="pollingToggles">
                <div class="form-group">
                    <label>Multi-PID:</label>
                    <input type="checkbox" id="useMultiPid">
                    <span class="help-text">Combine PIDs into single query</span>
                </div>
                <div class="form-group">
                    <label>Repeat:</label>
                    <input type="checkbox" id="useRepeat">
                    <span class="help-text">Use repeat command for identical queries</span>
                </div>
                <div class="form-group" id="repeatStringGroup" style="display: none;">
                    <label>Repeat String:</label>
                    <input type="text" id="repeatString" value="" style="width: 80px;">
                    <span class="help-text">Empty = bare CR (ELM327 spec), "1" = WiFi dongle</span>
                </div>
                <div class="form-group">
                    <label>Framing (ATH1):</label>
                    <input type="checkbox" id="useFraming">
                    <span class="help-text">Enable CAN headers for reliable ECU counting</span>
                </div>
                <div class="form-group">
                    <label>Pipelining:</label>
                    <input type="checkbox" id="usePipelining">
                    <span class="help-text">Keep 1 request in-flight for higher throughput</span>
                </div>
            </div>
            
            <div style="margin: 15px 0;">
                <button id="startBtn" onclick="startTest()">Start Test</button>
                <button id="stopBtn" onclick="stopTest()" disabled>Stop Test</button>
            </div>
            
            <div style="margin-top: 10px;">
                <span id="testStatus">
                    <span class="status-indicator status-disconnected"></span>
                    Stopped
                </span>
            </div>
        </div>

        <!-- Live Metrics -->
        <div class="section metrics-section">
            <h2 style="margin-top: 0;">Live Metrics</h2>
            <div>
                <div class="metric">
                    <div class="metric-value" id="reqsPerSec">0</div>
                    <div class="metric-label">Requests/sec</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="totalReqs">0</div>
                    <div class="metric-label">Total Requests</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="totalErrors">0</div>
                    <div class="metric-label">Errors</div>
                </div>
            </div>
            <div style="margin-top: 15px;">
                <span id="dongleStatus">
                    <span class="status-indicator status-disconnected"></span>
                    Dongle: Disconnected
                </span>
            </div>
            
            <!-- Capture-specific metrics (Mode 5) -->
            <div id="captureMetrics" class="capture-section">
                <h3>Capture Status</h3>
                <div style="margin: 10px 0;">
                    <span id="clientStatus">
                        <span class="status-indicator status-disconnected"></span>
                        Client: Disconnected
                    </span>
                </div>
                <div class="form-group">
                    <label>Buffer Usage:</label>
                    <div class="progress-bar">
                        <div id="bufferProgress" class="progress-fill" style="width: 0%"></div>
                    </div>
                </div>
                <div>
                    <span id="bytesCapture">0</span> bytes / 
                    <span id="recordsCapture">0</span> records
                </div>
                <div id="overflowWarning" style="color: #ff4444; display: none;">
                    ⚠️ Buffer overflow - capture stopped
                </div>
                <div style="margin-top: 10px;">
                    <button id="downloadCaptureBtn" onclick="downloadCapture()" disabled>Download Capture</button>
                    <button id="decodeCaptureBtn" onclick="decodeCapture()" disabled>Decode Capture</button>
                    <button id="clearCaptureBtn" onclick="clearCapture()" class="danger" disabled>Clear Buffer</button>
                </div>
            </div>
        </div>

        <!-- PID Values -->
        <div id="pidValuesSection" class="section metrics-section" style="display: none;">
            <h2 style="margin-top: 0;">PID Values</h2>
            <table class="pid-values-table">
                <thead>
                    <tr>
                        <th>PID</th>
                        <th>Name</th>
                        <th>Value</th>
                        <th>Raw</th>
                    </tr>
                </thead>
                <tbody id="pidValuesBody"></tbody>
            </table>
        </div>

        <!-- Capture Decoder Output -->
        <div id="decodeSection" class="section" style="display: none;">
            <div style="display: flex; align-items: center; justify-content: space-between;">
                <h2 style="margin-top: 0;">Capture Decoder</h2>
                <button onclick="closeDecoder()" style="padding: 5px 10px; font-size: 16px;">✕</button>
            </div>
            <div id="decodeHeaderInfo"></div>
            <div class="decode-controls">
                <label>Filter:
                    <select id="decodeFilter" onchange="applyDecodeFilter()">
                        <option value="all">All</option>
                        <option value="0">TX</option>
                        <option value="1">RX</option>
                        <option value="2">CONNECT</option>
                        <option value="3">DISCONNECT</option>
                    </select>
                </label>
                <label><input type="checkbox" id="hexToggle" onchange="toggleDecodeHex()"> Hex</label>
                <span id="decodeRecordCount" class="decode-record-count"></span>
            </div>
            <div class="decode-col-header">
                <div class="dc-num">#</div>
                <div class="dc-time">Time (ms)</div>
                <div class="dc-type">Type</div>
                <div class="dc-bytes">Bytes</div>
                <div class="dc-data">Data</div>
            </div>
            <div id="decodeScrollContainer" class="decode-scroll-container">
                <div id="decodeSpacer" style="position: relative;"></div>
            </div>
        </div>

        <!-- Test Configuration -->
        <div class="section">
            <h2 style="margin-top: 0;">Test Configuration</h2>
            
            <div class="form-group">
                <label>Dongle IP:</label>
                <input type="text" id="dongleIp" value="192.168.0.10">
            </div>
            <div class="form-group">
                <label>Dongle Port:</label>
                <input type="number" id="donglePort" value="35000" min="1" max="65535">
            </div>
            <div class="form-group">
                <label>OBD2 Timeout (ms):</label>
                <input type="number" id="obd2Timeout" value="1000" min="100" max="10000">
            </div>
            
            <h3>PIDs to Poll</h3>
            <div class="form-group pid-list">
                <label>Fast PIDs:</label>
                <input type="text" id="fastPids" value="010C,0149">
                <div class="help-text">Comma-separated, polled at 6:1 ratio vs slow PIDs</div>
            </div>
            <div class="form-group pid-list">
                <label>Slow PIDs:</label>
                <input type="text" id="slowPids" value="0105">
                <div class="help-text">Comma-separated, polled less frequently</div>
            </div>
            
            <!-- Mode 5 specific -->
            <div id="captureConfig" class="capture-section">
                <h3>Capture Settings</h3>
                <div class="form-group">
                    <label>Listen Port:</label>
                    <input type="number" id="listenPort" value="35000" min="1" max="65535">
                </div>
                <div class="form-group">
                    <label>Buffer Size (MB):</label>
                    <input type="number" id="captureBuffer" value="4" min="1" max="6">
                </div>
                <div class="form-group">
                    <label>On Overflow:</label>
                    <select id="captureOverflow">
                        <option value="stop">Stop capture</option>
                        <option value="wrap">Wrap (lose oldest)</option>
                    </select>
                </div>
            </div>
            
            <button onclick="saveConfig()">Save Configuration</button>
        </div>

        <!-- WiFi Configuration -->
        <div class="section wifi-section">
            <h2 style="margin-top: 0;">WiFi Configuration</h2>
            
            <h3>Station (Connect to OBD2 Dongle)</h3>
            <div class="form-group">
                <label>SSID:</label>
                <input type="text" id="wifiSsid">
                <button onclick="scanWifi()" style="padding: 5px 10px; margin-left: 5px;">Scan</button>
            </div>
            <div id="wifiList" style="display: none; margin: 10px 0 10px 155px;"></div>
            <div class="form-group">
                <label>Password:</label>
                <input type="password" id="wifiPassword">
            </div>
            <div class="form-group">
                <label>Use DHCP:</label>
                <input type="checkbox" id="useDhcp" checked>
            </div>
            <div id="staticIpConfig" style="display: none;">
                <div class="form-group">
                    <label>Static IP:</label>
                    <input type="text" id="staticIp" value="192.168.0.100">
                </div>
                <div class="form-group">
                    <label>Prefix Length:</label>
                    <input type="number" id="prefixLen" value="24" min="1" max="32">
                </div>
            </div>
            
            <h3>Access Point</h3>
            <div class="form-group">
                <label>AP SSID:</label>
                <input type="text" id="apSsid" value="TachTalk-Test">
            </div>
            <div class="form-group">
                <label>AP Password:</label>
                <input type="password" id="apPassword" placeholder="Leave empty for open">
            </div>
            
            <button onclick="saveConfig()">Save WiFi Settings</button>
        </div>

        <!-- System -->
        <div class="section">
            <h2 style="margin-top: 0;">System</h2>
            <div class="form-group">
                <label>Log Level:</label>
                <select id="logLevel">
                    <option value="error">Error</option>
                    <option value="warn">Warn</option>
                    <option value="info">Info</option>
                    <option value="debug">Debug</option>
                </select>
            </div>
            <button onclick="rebootDevice()" class="danger">Reboot Device</button>
        </div>
    </div>

    <script>
        let config = {};
        let eventSource = null;
        const modeDescriptions = {
            'no_count': "Send PIDs as-is without response count. Baseline for comparison - dongle uses adaptive timing (~200ms wait).",
            'always_one': "Append ' 1' to all requests to tell dongle to return after 1 ECU response. Should be faster than NoCount.",
            'adaptive_count': "First request detects how many responses the ECU sends, then uses that count for subsequent requests.",
            'raw_capture': "Pure TCP proxy mode. Records all traffic to PSRAM buffer for later download and analysis."
        };

        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                config = await response.json();
                populateForm();
            } catch (e) {
                showStatus('Failed to load config: ' + e, 'error');
            }
        }

        function populateForm() {
            // Test config
            document.getElementById('queryMode').value = config.test?.query_mode || 'no_count';
            document.getElementById('dongleIp').value = config.test?.dongle_ip || '192.168.0.10';
            document.getElementById('donglePort').value = config.test?.dongle_port || 35000;
            document.getElementById('obd2Timeout').value = config.test?.obd2_timeout_ms || 1000;
            document.getElementById('fastPids').value = config.test?.fast_pids || '010C,0149';
            document.getElementById('slowPids').value = config.test?.slow_pids || '0105';
            document.getElementById('listenPort').value = config.test?.listen_port || 35000;
            document.getElementById('captureBuffer').value = (config.test?.capture_buffer_size || 4194304) / 1048576;
            document.getElementById('captureOverflow').value = config.test?.capture_overflow || 'stop';
            
            // WiFi config
            document.getElementById('wifiSsid').value = config.wifi?.ssid || '';
            document.getElementById('wifiPassword').value = config.wifi?.password || '';
            document.getElementById('useDhcp').checked = config.ip?.use_dhcp !== false;
            document.getElementById('staticIp').value = config.ip?.ip || '192.168.0.100';
            document.getElementById('prefixLen').value = config.ip?.prefix_len || 24;
            document.getElementById('apSsid').value = config.ap_ssid || 'TachTalk-Test';
            document.getElementById('apPassword').value = config.ap_password || '';
            document.getElementById('logLevel').value = config.log_level || 'info';
            
            updateModeUI();
            updateDhcpUI();
        }

        function updateModeUI() {
            const mode = document.getElementById('queryMode').value;
            document.getElementById('modeDescription').textContent = modeDescriptions[mode];
            
            // Show/hide mode-specific config
            document.getElementById('captureConfig').classList.toggle('visible', mode === 'raw_capture');
            document.getElementById('captureMetrics').classList.toggle('visible', true);
            
            // Show/hide polling toggles (only for polling modes)
            const isPolling = mode !== 'raw_capture';
            document.getElementById('pollingToggles').style.display = isPolling ? 'block' : 'none';
        }

        function updateRepeatUI() {
            document.getElementById('repeatStringGroup').style.display =
                document.getElementById('useRepeat').checked ? 'block' : 'none';
        }

        function updateDhcpUI() {
            document.getElementById('staticIpConfig').style.display = 
                document.getElementById('useDhcp').checked ? 'none' : 'block';
        }

        async function saveConfig() {
            const newConfig = {
                ...config,
                test: {
                    dongle_ip: document.getElementById('dongleIp').value,
                    dongle_port: parseInt(document.getElementById('donglePort').value),
                    obd2_timeout_ms: parseInt(document.getElementById('obd2Timeout').value),
                    fast_pids: document.getElementById('fastPids').value,
                    slow_pids: document.getElementById('slowPids').value,
                    listen_port: parseInt(document.getElementById('listenPort').value),
                    capture_buffer_size: parseInt(document.getElementById('captureBuffer').value) * 1048576,
                    capture_overflow: document.getElementById('captureOverflow').value
                },
                wifi: {
                    ssid: document.getElementById('wifiSsid').value,
                    password: document.getElementById('wifiPassword').value || null
                },
                ip: {
                    use_dhcp: document.getElementById('useDhcp').checked,
                    ip: document.getElementById('staticIp').value,
                    prefix_len: parseInt(document.getElementById('prefixLen').value)
                },
                ap_ssid: document.getElementById('apSsid').value,
                ap_password: document.getElementById('apPassword').value || null,
                log_level: document.getElementById('logLevel').value
            };

            try {
                const checkResponse = await fetch('/api/config/check', {
                    method: 'POST',
                    body: JSON.stringify(newConfig)
                });
                const checkResult = await checkResponse.json();
                
                if (checkResult.restart) {
                    if (!confirm('This change requires a device restart. Continue?')) {
                        return;
                    }
                }

                const response = await fetch('/api/config', {
                    method: 'POST',
                    body: JSON.stringify(newConfig)
                });
                
                if (response.ok) {
                    const result = await response.json().catch(() => ({}));
                    if (result.restart) {
                        showStatus('Config saved. Device restarting...', 'success');
                    } else {
                        showStatus('Config saved!', 'success');
                        config = newConfig;
                    }
                } else {
                    showStatus('Failed to save config', 'error');
                }
            } catch (e) {
                showStatus('Error: ' + e, 'error');
            }
        }

        async function startTest() {
            try {
                const queryMode = document.getElementById('queryMode').value;
                const body = { query_mode: queryMode };
                
                // Add polling toggles for non-capture modes
                if (queryMode !== 'raw_capture') {
                    body.use_multi_pid = document.getElementById('useMultiPid').checked;
                    body.use_repeat = document.getElementById('useRepeat').checked;
                    body.repeat_string = document.getElementById('repeatString').value;
                    body.use_framing = document.getElementById('useFraming').checked;
                    body.use_pipelining = document.getElementById('usePipelining').checked;
                }
                
                await fetch('/api/test/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
            } catch (e) {
                showStatus('Failed to start test: ' + e, 'error');
            }
        }

        async function stopTest() {
            try {
                await fetch('/api/test/stop', { method: 'POST' });
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            } catch (e) {
                showStatus('Failed to stop test: ' + e, 'error');
            }
        }

        async function scanWifi() {
            const listDiv = document.getElementById('wifiList');
            listDiv.style.display = 'block';
            listDiv.innerHTML = 'Scanning...';
            
            try {
                const response = await fetch('/api/wifi/scan');
                const networks = await response.json();
                
                if (networks.length === 0) {
                    listDiv.innerHTML = 'No networks found';
                    return;
                }
                
                listDiv.innerHTML = networks.map(n => 
                    `<div style="cursor: pointer; padding: 5px; margin: 2px 0; background: #333; border-radius: 3px;" 
                         onclick="selectWifi('${n.ssid}')">${n.ssid} (${n.rssi} dBm)</div>`
                ).join('');
            } catch (e) {
                listDiv.innerHTML = 'Scan failed: ' + e;
            }
        }

        function selectWifi(ssid) {
            document.getElementById('wifiSsid').value = ssid;
            document.getElementById('wifiList').style.display = 'none';
        }

        async function rebootDevice() {
            if (!confirm('Are you sure you want to reboot?')) return;
            
            try {
                await fetch('/api/reboot', { method: 'POST' });
                showStatus('Device rebooting...', 'success');
            } catch (e) {
                showStatus('Reboot command sent', 'success');
            }
        }

        async function downloadCapture() {
            try {
                const response = await fetch('/api/capture');
                if (response.status === 204) {
                    showStatus('No capture data to download', 'error');
                    return;
                }
                if (response.status === 409) {
                    showStatus('Stop the test before downloading', 'error');
                    return;
                }
                if (!response.ok) {
                    showStatus('Download failed: ' + response.statusText, 'error');
                    return;
                }
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'capture_' + new Date().toISOString().replace(/[:.]/g, '-') + '.ttcap';
                a.click();
                URL.revokeObjectURL(url);
                showStatus('Capture downloaded (' + blob.size + ' bytes)', 'success');
            } catch (e) {
                showStatus('Download error: ' + e, 'error');
            }
        }

        async function clearCapture() {
            if (!confirm('Clear the capture buffer? This cannot be undone.')) return;
            
            try {
                const response = await fetch('/api/capture/clear', { method: 'POST' });
                if (response.status === 409) {
                    showStatus('Stop the test before clearing', 'error');
                    return;
                }
                if (response.ok) {
                    showStatus('Capture buffer cleared', 'success');
                } else {
                    showStatus('Clear failed: ' + response.statusText, 'error');
                }
            } catch (e) {
                showStatus('Clear error: ' + e, 'error');
            }
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = type;
            status.style.display = 'block';
            setTimeout(() => { status.style.display = 'none'; }, 5000);
        }

        function updateMetrics(data) {
            document.getElementById('reqsPerSec').textContent = data.requests_per_sec || 0;
            document.getElementById('totalReqs').textContent = data.total_requests || 0;
            document.getElementById('totalErrors').textContent = data.total_errors || 0;
            
            // Update dongle status
            const dongleIndicator = document.querySelector('#dongleStatus .status-indicator');
            dongleIndicator.className = 'status-indicator ' + (data.dongle_connected ? 'status-connected' : 'status-disconnected');
            document.getElementById('dongleStatus').innerHTML = 
                `<span class="status-indicator ${data.dongle_connected ? 'status-connected' : 'status-disconnected'}"></span>` +
                `Dongle: ${data.dongle_connected ? 'Connected' : 'Disconnected'}`;
            
            // Update test status
            const testRunning = data.test_running;
            document.getElementById('startBtn').disabled = testRunning;
            document.getElementById('stopBtn').disabled = !testRunning;
            document.getElementById('testStatus').innerHTML = 
                `<span class="status-indicator ${testRunning ? 'status-running' : 'status-disconnected'}"></span>` +
                `${testRunning ? 'Running' : 'Stopped'}`;
            
            // Update capture metrics
            const mode = document.getElementById('queryMode').value;
            // Client status only relevant for raw_capture (TCP proxy)
            const clientStatusEl = document.getElementById('clientStatus');
            if (mode === 'raw_capture') {
                clientStatusEl.style.display = '';
                clientStatusEl.innerHTML = 
                    `<span class="status-indicator ${data.client_connected ? 'status-connected' : 'status-disconnected'}"></span>` +
                    `Client: ${data.client_connected ? 'Connected' : 'Disconnected'}`;
            } else {
                clientStatusEl.style.display = 'none';
            }
            
            const bufferPct = data.buffer_usage_pct || 0;
            const progressBar = document.getElementById('bufferProgress');
            progressBar.style.width = bufferPct + '%';
            progressBar.className = 'progress-fill' + 
                (bufferPct > 90 ? ' danger' : bufferPct > 70 ? ' warning' : '');
            
            document.getElementById('bytesCapture').textContent = data.bytes_captured || 0;
            document.getElementById('recordsCapture').textContent = data.records_captured || 0;
            document.getElementById('overflowWarning').style.display = data.capture_overflow ? 'block' : 'none';

            // Enable download/clear only when test is stopped and buffer has data
            const hasData = (data.bytes_captured || 0) > 0;
            document.getElementById('downloadCaptureBtn').disabled = testRunning || !hasData;
            document.getElementById('decodeCaptureBtn').disabled = testRunning || !hasData;
            document.getElementById('clearCaptureBtn').disabled = testRunning || !hasData;

            // Update PID values
            updatePidValues(data.pid_values);
        }

        // === PID Value Decoder ===
        const PID_INFO = {
            0x00: { name: 'PIDs supported [01-20]', decode: (b) => 'bitmask' },
            0x01: { name: 'Monitor status', decode: (b) => 'flags' },
            0x03: { name: 'Fuel system status', decode: (b) => 'status' },
            0x04: { name: 'Engine load', decode: (b) => (b[0] * 100 / 255).toFixed(1) + ' %' },
            0x05: { name: 'Coolant temp', decode: (b) => (b[0] - 40) + ' °C' },
            0x06: { name: 'Short fuel trim B1', decode: (b) => ((b[0] - 128) * 100 / 128).toFixed(1) + ' %' },
            0x07: { name: 'Long fuel trim B1', decode: (b) => ((b[0] - 128) * 100 / 128).toFixed(1) + ' %' },
            0x0B: { name: 'Intake MAP', decode: (b) => b[0] + ' kPa' },
            0x0C: { name: 'RPM', decode: (b) => ((b[0] * 256 + b[1]) / 4).toFixed(0) + ' rpm' },
            0x0D: { name: 'Speed', decode: (b) => b[0] + ' km/h' },
            0x0E: { name: 'Timing advance', decode: (b) => (b[0] / 2 - 64).toFixed(1) + ' °' },
            0x0F: { name: 'Intake air temp', decode: (b) => (b[0] - 40) + ' °C' },
            0x10: { name: 'MAF rate', decode: (b) => ((b[0] * 256 + b[1]) / 100).toFixed(2) + ' g/s' },
            0x11: { name: 'Throttle pos', decode: (b) => (b[0] * 100 / 255).toFixed(1) + ' %' },
            0x1C: { name: 'OBD standard', decode: (b) => 'type ' + b[0] },
            0x1F: { name: 'Run time', decode: (b) => (b[0] * 256 + b[1]) + ' s' },
            0x21: { name: 'Distance w/ MIL', decode: (b) => (b[0] * 256 + b[1]) + ' km' },
            0x2F: { name: 'Fuel level', decode: (b) => (b[0] * 100 / 255).toFixed(1) + ' %' },
            0x31: { name: 'Distance since clear', decode: (b) => (b[0] * 256 + b[1]) + ' km' },
            0x33: { name: 'Baro pressure', decode: (b) => b[0] + ' kPa' },
            0x42: { name: 'Control voltage', decode: (b) => ((b[0] * 256 + b[1]) / 1000).toFixed(3) + ' V' },
            0x46: { name: 'Ambient temp', decode: (b) => (b[0] - 40) + ' °C' },
            0x49: { name: 'Hybrid battery life', decode: (b) => (b[0] * 100 / 255).toFixed(1) + ' %' },
            0x51: { name: 'Fuel type', decode: (b) => 'type ' + b[0] },
            0x5C: { name: 'Oil temp', decode: (b) => (b[0] - 40) + ' °C' },
        };

        function pidHex(pid) {
            return pid.toString(16).toUpperCase().padStart(2, '0');
        }

        function updatePidValues(pidValues) {
            const section = document.getElementById('pidValuesSection');
            const tbody = document.getElementById('pidValuesBody');

            if (!pidValues || Object.keys(pidValues).length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = '';

            // Sort PIDs numerically
            const pids = Object.keys(pidValues)
                .map(k => parseInt(k, 16))
                .sort((a, b) => a - b);

            // Build table rows
            let html = '';
            for (const pid of pids) {
                const key = pidHex(pid);
                const entry = pidValues[key];
                const info = PID_INFO[pid];
                const name = info ? info.name : 'Unknown';

                if (entry.e !== undefined) {
                    // Error
                    html += `<tr>
                        <td class="pid-hex">0x${key}</td>
                        <td class="pid-name">${name}</td>
                        <td class="pid-error" colspan="2">${entry.e}</td>
                    </tr>`;
                } else if (entry.v !== undefined) {
                    const raw = entry.v.map(b => b.toString(16).toUpperCase().padStart(2, '0')).join(' ');
                    let decoded = raw;
                    if (info && info.decode) {
                        try { decoded = info.decode(entry.v); } catch (e) { /* use raw */ }
                    }
                    html += `<tr>
                        <td class="pid-hex">0x${key}</td>
                        <td class="pid-name">${name}</td>
                        <td class="pid-decoded">${decoded}</td>
                        <td class="pid-raw">${raw}</td>
                    </tr>`;
                }
            }
            tbody.innerHTML = html;
        }

        function connectSSE() {
            if (eventSource) {
                eventSource.close();
            }
            
            const port = typeof SSE_PORT !== 'undefined' ? SSE_PORT : 81;
            const sseUrl = `http://${window.location.hostname}:${port}/events`;
            
            eventSource = new EventSource(sseUrl);
            
            eventSource.addEventListener('metrics', (e) => {
                try {
                    const data = JSON.parse(e.data);
                    updateMetrics(data);
                } catch (err) {
                    console.error('Failed to parse metrics:', err);
                }
            });
            
            eventSource.onerror = () => {
                console.log('SSE connection lost, reconnecting...');
                setTimeout(connectSSE, 2000);
            };
        }

        // === Capture Decoder ===
        const CAPTURE_MAGIC = 'TachTalk';
        const CAPTURE_HDR_SIZE = 64;
        const REC_HDR_SIZE = 7;
        const FL_OVERFLOW = 0x0001;
        const FL_NTP_SYNCED = 0x0002;
        const REC_TYPES = {
            0: { label: 'TX', cls: 'rt-tx' },
            1: { label: 'RX', cls: 'rt-rx' },
            2: { label: 'CONNECT', cls: 'rt-connect' },
            3: { label: 'DISCONNECT', cls: 'rt-disconnect' },
        };
        const ROW_H = 28;
        const OVERSCAN = 15;

        let decAllRecords = [];
        let decFiltered = [];
        let decHex = false;
        let decRafPending = false;

        function u64LE(dv, o) {
            return dv.getUint32(o, true) + dv.getUint32(o + 4, true) * 0x100000000;
        }

        function nullStr(dv, o, n) {
            let s = '';
            for (let i = 0; i < n; i++) {
                const b = dv.getUint8(o + i);
                if (b === 0) break;
                s += String.fromCharCode(b);
            }
            return s;
        }

        function parseCaptureHdr(dv) {
            let magic = '';
            for (let i = 0; i < 8; i++) magic += String.fromCharCode(dv.getUint8(i));
            if (magic !== CAPTURE_MAGIC)
                throw new Error('Invalid capture file: bad magic "' + magic + '"');
            return {
                version: dv.getUint16(8, true),
                headerSize: dv.getUint16(10, true),
                recordCount: dv.getUint32(12, true),
                dataLength: dv.getUint32(16, true),
                captureStartMs: u64LE(dv, 20),
                dongleIp: dv.getUint8(28) + '.' + dv.getUint8(29) + '.' +
                          dv.getUint8(30) + '.' + dv.getUint8(31),
                donglePort: dv.getUint16(32, true),
                flags: dv.getUint16(34, true),
                firmware: nullStr(dv, 36, 16),
            };
        }

        function parseCaptureRecs(buf, hdrSize) {
            const dv = new DataView(buf);
            const recs = [];
            let off = hdrSize;
            const end = buf.byteLength;
            let idx = 1;
            while (off + REC_HDR_SIZE <= end) {
                const ts = dv.getUint32(off, true);
                const rt = dv.getUint8(off + 4);
                const dl = dv.getUint16(off + 5, true);
                off += REC_HDR_SIZE;
                if (off + dl > end) break;
                recs.push({ index: idx++, timestampMs: ts, recordType: rt,
                            data: new Uint8Array(buf, off, dl) });
                off += dl;
            }
            return recs;
        }

        function fmtText(data) {
            if (!data.length) return '(no data)';
            let s = '';
            for (const b of data) {
                if (b === 0x0d) s += '\\r';
                else if (b === 0x0a) s += '\\n';
                else if (b === 0x09) s += '\\t';
                else if (b >= 0x20 && b <= 0x7e) s += String.fromCharCode(b);
                else s += '\\x' + b.toString(16).padStart(2, '0');
            }
            return s;
        }

        function fmtHex(data) {
            if (!data.length) return '(no data)';
            return Array.from(data, b => b.toString(16).padStart(2, '0')).join(' ');
        }

        function escH(s) {
            return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        function escA(s) {
            return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        async function decodeCapture() {
            try {
                const resp = await fetch('/api/capture');
                if (resp.status === 204) { showStatus('No capture data', 'error'); return; }
                if (resp.status === 409) { showStatus('Stop the test first', 'error'); return; }
                if (!resp.ok) { showStatus('Fetch failed: ' + resp.statusText, 'error'); return; }

                const buf = await resp.arrayBuffer();
                if (buf.byteLength < CAPTURE_HDR_SIZE) {
                    showStatus('Capture file too small', 'error');
                    return;
                }

                const dv = new DataView(buf);
                const hdr = parseCaptureHdr(dv);
                if (hdr.version !== 1) {
                    showStatus('Unsupported capture version: ' + hdr.version, 'error');
                    return;
                }

                decAllRecords = parseCaptureRecs(buf, hdr.headerSize);
                renderDecodeHdr(hdr, buf.byteLength);

                document.getElementById('decodeFilter').value = 'all';
                decHex = false;
                document.getElementById('hexToggle').checked = false;
                applyDecodeFilter();

                document.getElementById('decodeSection').style.display = 'block';
                document.getElementById('decodeSection').scrollIntoView({ behavior: 'smooth' });
            } catch (e) {
                showStatus('Decode error: ' + e.message, 'error');
            }
        }

        function renderDecodeHdr(hdr, fileSize) {
            const flags = [];
            if (hdr.flags & FL_OVERFLOW)
                flags.push('<span class="flag-badge flag-overflow">OVERFLOW</span>');
            if (hdr.flags & FL_NTP_SYNCED)
                flags.push('<span class="flag-badge flag-ntp">NTP SYNCED</span>');

            let startStr = '(no NTP)';
            if (hdr.captureStartMs > 0) {
                const d = new Date(hdr.captureStartMs);
                startStr = d.toISOString().replace('T', ' ').replace('Z', ' UTC');
            }

            document.getElementById('decodeHeaderInfo').innerHTML =
                '<dl class="decode-header-card">' +
                '<dt>File Size</dt><dd>' + fileSize.toLocaleString() + ' bytes</dd>' +
                '<dt>Format Version</dt><dd>' + hdr.version + '</dd>' +
                '<dt>Records</dt><dd>' + hdr.recordCount.toLocaleString() + '</dd>' +
                '<dt>Data Length</dt><dd>' + hdr.dataLength.toLocaleString() + ' bytes</dd>' +
                '<dt>Firmware</dt><dd>' + escH(hdr.firmware || '(unknown)') + '</dd>' +
                '<dt>Dongle</dt><dd>' + hdr.dongleIp + ':' + hdr.donglePort + '</dd>' +
                '<dt>Capture Start</dt><dd>' + startStr + '</dd>' +
                '<dt>Flags</dt><dd>' + (flags.length ? flags.join(' ') : '(none)') + '</dd>' +
                '</dl>';
        }

        function applyDecodeFilter() {
            const v = document.getElementById('decodeFilter').value;
            if (v === 'all') {
                decFiltered = decAllRecords;
            } else {
                const t = parseInt(v, 10);
                decFiltered = decAllRecords.filter(r => r.recordType === t);
            }
            document.getElementById('decodeRecordCount').textContent =
                decFiltered.length.toLocaleString() + ' of ' +
                decAllRecords.length.toLocaleString() + ' records';
            document.getElementById('decodeSpacer').style.height =
                (decFiltered.length * ROW_H) + 'px';
            document.getElementById('decodeScrollContainer').scrollTop = 0;
            renderDecodeVisible();
        }

        function toggleDecodeHex() {
            decHex = document.getElementById('hexToggle').checked;
            renderDecodeVisible();
        }

        function renderDecodeVisible() {
            const ctr = document.getElementById('decodeScrollContainer');
            const spacer = document.getElementById('decodeSpacer');
            const st = ctr.scrollTop;
            const vh = ctr.clientHeight;

            const first = Math.floor(st / ROW_H);
            const count = Math.ceil(vh / ROW_H);
            const start = Math.max(0, first - OVERSCAN);
            const end = Math.min(decFiltered.length, first + count + OVERSCAN);

            let html = '';
            for (let i = start; i < end; i++) {
                const r = decFiltered[i];
                const rt = REC_TYPES[r.recordType] || { label: '?', cls: '' };
                const d = decHex ? fmtHex(r.data) : fmtText(r.data);
                html += '<div class="decode-row ' + rt.cls +
                    '" style="top:' + (i * ROW_H) + 'px">' +
                    '<div class="dc-num">' + r.index + '</div>' +
                    '<div class="dc-time">' + r.timestampMs + '</div>' +
                    '<div class="dc-type"><span class="type-badge ' + rt.cls +
                    '">' + rt.label + '</span></div>' +
                    '<div class="dc-bytes">' + r.data.length + '</div>' +
                    '<div class="dc-data" title="' + escA(d) + '">' +
                    escH(d) + '</div></div>';
            }
            spacer.innerHTML = html;
        }

        function onDecodeScroll() {
            if (!decRafPending) {
                decRafPending = true;
                requestAnimationFrame(() => {
                    decRafPending = false;
                    renderDecodeVisible();
                });
            }
        }

        function closeDecoder() {
            document.getElementById('decodeSection').style.display = 'none';
            decAllRecords = [];
            decFiltered = [];
            document.getElementById('decodeSpacer').innerHTML = '';
        }

        // Event listeners
        document.getElementById('decodeScrollContainer').addEventListener('scroll', onDecodeScroll);
        document.getElementById('queryMode').addEventListener('change', updateModeUI);
        document.getElementById('useDhcp').addEventListener('change', updateDhcpUI);
        document.getElementById('useRepeat').addEventListener('change', updateRepeatUI);

        // Initialize
        loadConfig();
        connectSSE();
    </script>
</body>
</html>
